package gocd

import (
	"bytes"
	"crypto/tls"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
	"strconv"
	"time"

	log "github.com/Sirupsen/logrus"
)

//  Server is an object representation of a GoCD server
type Server struct {
	Host     string
	Port     string
	User     string
	Password string
	Timeout  time.Duration
}

// NewServerConfig Create a Server object from a config
func NewServerConfig(host string, port string, user string, password string, timeoutStr string) *Server {

	// timeout casting to seconds
	timeout := time.Duration(120 * time.Second)
	i, err := strconv.Atoi(timeoutStr)
	if err == nil {
		timeout = time.Duration(i) * time.Second
	} else {
		log.Warn("Failed to convert timeout to seconds: ", err)
	}

	return &Server{
		Host:     host,
		Port:     port,
		User:     user,
		Password: password,
		Timeout:  timeout,
	}
}

// URL returns the host of the GoCD server
func (server Server) URL() string {
	return fmt.Sprintf("%s:%s", server.Host, server.Port)
}

// client returns a http client with longer timeout and skip verify
func client(timeout time.Duration) *http.Client {
	transCfg := &http.Transport{
		TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
	}
	return &http.Client{
		Timeout:   timeout,
		Transport: transCfg,
	}
}

func printPrettyJSON(body []byte, objectname string) (prettyJSON bytes.Buffer, err error) {
	err = json.Indent(&prettyJSON, body, "", "\t")
	if err != nil {
		log.Warn("Failed to prettify JSON: ", err)
	}
	log.Debug(objectname+" JSON:", string(prettyJSON.Bytes()))
	return
}

// readPipelineJSONFromFile reads a GoCD structure from a json file
func readPipelineJSONFromFile(path string) (pipeline Pipeline, err error) {
	data, err := ioutil.ReadFile(path)
	if err == nil {
		err = json.Unmarshal(data, &pipeline)
	}
	return
}

// Partially generated by curl-to-Go: https://mholt.github.io/curl-to-go
func (server Server) pipelineConfigPUT(pipeline Pipeline, etag string) (pipelineResult Pipeline, err error) {

	pipelineName := pipeline.Name

	payloadBytes, err := json.Marshal(pipeline)
	if err != nil {
		return
	}

	payloadBody := bytes.NewReader(payloadBytes)

	req, err := http.NewRequest("PUT", server.URL()+"/go/api/admin/pipelines/"+pipelineName, payloadBody)
	if err != nil {
		return
	}

	if len(server.User) > 0 && len(server.Password) > 0 {
		req.SetBasicAuth(server.User, server.Password)
	}
	req.Header.Set("Accept", "application/vnd.go.cd.v4+json")
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("If-Match", etag)

	log.Debugf("Sending request: %v", req)
	resp, err := client(server.Timeout).Do(req)
	if err != nil {
		return
	}
	defer resp.Body.Close()

	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return
	}

	if resp.StatusCode != 200 {
		err = fmt.Errorf("Bad response code: %d, response: %s", resp.StatusCode, body)
		return
	}

	printPrettyJSON(body, "pipelineConfig")

	err = json.Unmarshal(body, &pipelineResult)
	return
}

// Generated by curl-to-Go: https://mholt.github.io/curl-to-go
func (server Server) pipelineConfigPOST(pipelineConfig PipelineConfig) (pipeline Pipeline, err error) {
	payloadBytes, err := json.Marshal(pipelineConfig)
	if err != nil {
		return
	}

	payloadBody := bytes.NewReader(payloadBytes)

	req, err := http.NewRequest("POST", server.URL()+"/go/api/admin/pipelines", payloadBody)
	if err != nil {
		return
	}

	if len(server.User) > 0 && len(server.Password) > 0 {
		req.SetBasicAuth(server.User, server.Password)
	}
	req.Header.Set("Accept", "application/vnd.go.cd.v4+json")
	req.Header.Set("Content-Type", "application/json")

	log.Debugf("Sending request: %v", req)
	resp, err := client(server.Timeout).Do(req)
	if err != nil {
		return
	}
	defer resp.Body.Close()

	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return
	}

	if resp.StatusCode != 200 {
		err = fmt.Errorf("Bad response code: %d with response: %s", resp.StatusCode, body)
		return
	}

	printPrettyJSON(body, "pipelineConfig")

	err = json.Unmarshal(body, &pipeline)
	return
}

// Partially generated by curl-to-Go: https://mholt.github.io/curl-to-go
func (server Server) pipelineDELETE(pipelineName string) (pipeline Pipeline, err error) {
	req, err := http.NewRequest("DELETE", server.URL()+"/go/api/admin/pipelines/"+pipelineName, nil)
	if err != nil {
		return
	}

	if len(server.User) > 0 && len(server.Password) > 0 {
		req.SetBasicAuth(server.User, server.Password)
	}
	req.Header.Set("Accept", "application/vnd.go.cd.v4+json")

	resp, err := client(server.Timeout).Do(req)
	if err != nil {
		return
	}
	defer resp.Body.Close()

	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return
	}

	if resp.StatusCode != 200 {
		err = fmt.Errorf("Bad response code: %d with response: %s using server url: %s", resp.StatusCode, body, server.URL())
		return
	}

	err = json.Unmarshal(body, &pipeline)
	return
}

// Partially generated by curl-to-Go: https://mholt.github.io/curl-to-go
func (server Server) environmentGET() (environment []Environment, err error) {
	req, err := http.NewRequest("GET", server.URL()+"/go/api/admin/environments", nil)
	if err != nil {
		return
	}

	if len(server.User) > 0 && len(server.Password) > 0 {
		req.SetBasicAuth(server.User, server.Password)
	}
	req.Header.Set("Accept", "application/vnd.go.cd.v2+json")

	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return
	}
	defer resp.Body.Close()

	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return
	}

	if resp.StatusCode != 200 {
		err = fmt.Errorf("Bad response code: %d with response: %s", resp.StatusCode, body)
		return
	}

	var fullReturn EnvironmentConfig
	err = json.Unmarshal(body, &fullReturn)

	environment = fullReturn.Embedded.Environment

	return
}

func findPipelineInEnvironment(environment []Environment, pipelineName string) (envName string) {
	//var envName string
	envName = ""

	for _, v := range environment {
		for _, p := range v.Pipelines {
			if p.Name == pipelineName {
				envName = v.Name
				return
			}
		}
	}

	return
}

// Partially generated by curl-to-Go: https://mholt.github.io/curl-to-go
func (server Server) environmentPATCH(pipelineName string, environmentName string) (err error) {
	data := PatchPayload{}
	data.Pipelines.Remove = []string{pipelineName}

	payloadBytes, err := json.Marshal(data)
	if err != nil {
		return
	}
	payloadBody := bytes.NewReader(payloadBytes)

	req, err := http.NewRequest("PATCH", server.URL()+"/go/api/admin/environments/"+environmentName, payloadBody)
	if err != nil {
		return
	}

	if len(server.User) > 0 && len(server.Password) > 0 {
		req.SetBasicAuth(server.User, server.Password)
	}
	req.Header.Set("Accept", "application/vnd.go.cd.v2+json")
	req.Header.Set("Content-Type", "application/json")

	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return
	}
	defer resp.Body.Close()

	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return
	}

	if resp.StatusCode != 200 {
		err = fmt.Errorf("Bad response code: %d with response: %s", resp.StatusCode, body)
		return
	}

	return
}

// Partially generated by curl-to-Go: https://mholt.github.io/curl-to-go
func (server Server) pipelineGET(pipelineName string) (pipeline Pipeline, etag string, err error) {
	req, err := http.NewRequest("GET", server.URL()+"/go/api/admin/pipelines/"+pipelineName, nil)
	if err != nil {
		return
	}

	if len(server.User) > 0 && len(server.Password) > 0 {
		req.SetBasicAuth(server.User, server.Password)
	}
	req.Header.Set("Accept", "application/vnd.go.cd.v4+json")
	req.Header.Set("Content-Type", "application/json")

	log.Debugf("Sending request: %v", req)
	resp, err := client(server.Timeout).Do(req)
	if err != nil {
		return
	}
	defer resp.Body.Close()

	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return
	}

	if resp.StatusCode != 200 {
		err = fmt.Errorf("Bad response code: %d with response: %s", resp.StatusCode, body)
		return
	}

	printPrettyJSON(body, "pipelineConfig")

	etag = resp.Header.Get("ETag")
	err = json.Unmarshal(body, &pipeline)
	return
}

// Partially generated by curl-to-Go: https://mholt.github.io/curl-to-go
func (server Server) artifactGET(pipelineName string, pipelineID int, stageName string, stageID int, jobName string, artifactPath string) (fileBytes *bytes.Buffer, err error) {
	reqStr := fmt.Sprintf("%s/go/files/%s/%d/%s/%d/%s/%s/", server.URL(),
		pipelineName, pipelineID, stageName, stageID, jobName, artifactPath)
	req, err := http.NewRequest("GET", reqStr, nil)
	if err != nil {
		return
	}

	if len(server.User) > 0 && len(server.Password) > 0 {
		req.SetBasicAuth(server.User, server.Password)
	}
	req.Header.Set("Content-Type", "application/json")

	log.Debugf("Sending request: %v", req)
	resp, err := client(server.Timeout).Do(req)
	if err != nil {
		return
	}
	defer resp.Body.Close()

	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return
	}

	if resp.StatusCode != 200 {
		err = fmt.Errorf("Bad response code: %d with response: %s", resp.StatusCode, body)
		return
	}

	fileBytes = bytes.NewBuffer(body)
	return
}

// Partially generated by curl-to-Go: https://mholt.github.io/curl-to-go
func (server Server) historyGET(pipelineName string) (historyJSON bytes.Buffer, err error) {
	req, err := http.NewRequest("GET", server.URL()+"/go/api/pipelines/"+pipelineName+"/history", nil)
	if err != nil {
		return
	}

	if len(server.User) > 0 && len(server.Password) > 0 {
		req.SetBasicAuth(server.User, server.Password)
	}
	req.Header.Set("Content-Type", "application/json")

	log.Debugf("Sending request: %v", req)
	resp, err := client(server.Timeout).Do(req)
	if err != nil {
		return
	}
	defer resp.Body.Close()

	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return
	}

	if resp.StatusCode != 200 {
		err = fmt.Errorf("Bad response code: %d with response: %s", resp.StatusCode, body)
		return
	}

	historyJSON, err = printPrettyJSON(body, "pipelineHistory")
	return
}

// writePipeline helper function to write a pipeline to file
func writePipeline(path string, pipeline Pipeline) (err error) {
	pipelineJSON, _ := json.MarshalIndent(pipeline, "", "    ")
	err = ioutil.WriteFile(path, pipelineJSON, 0666)
	return
}
